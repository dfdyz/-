# 补充一些重要知识点顺便回顾勇士传说的写法

## 一、组件化

### 首先，什么是组件？

![image-20231126141400043](https://image-wai.oss-cn-guangzhou.aliyuncs.com/img/image-20231126141400043.png)

点开一个GameObject，上面的所有的带标题功能都是组件

组件为我们提供了生命周期函数，协程，GameObject方法

+ `GetComponent<T>()`是GameObject类中的泛型方法，获取到一个GameObject对象就可以取的他和他子物体上的所有Component

### 勇士传说中的做法

如果我们最简单的实现一个玩家地面检测要怎么做

+ PlayerController.cs

![image-20231113180349379](https://image-wai.oss-cn-guangzhou.aliyuncs.com/img/image-20231113180349379.png)

很简单直接调用api获取结果即可，但如果小怪也需要地面检测呢（比如希望小怪下落的时候有下落动画

同样的逻辑再在小怪里写一次

+ Enemy.cs

![image-20231113180622137](https://image-wai.oss-cn-guangzhou.aliyuncs.com/img/image-20231113180622137.png)

发现了吗，两段逻辑是完全相同的，却要写两遍，这就很没有必要



再来看看勇士传说怎么做的

![image-20231113180959167](https://image-wai.oss-cn-guangzhou.aliyuncs.com/img/image-20231113180959167.png)

用一个组件负责tick时检查对应位置是否有地面，并public返回结果

这样一个地面检查的组件，就只和你设置的脚的位置，检测范围有关（你甚至可以把他抽象成一个圆形范围检测组件



**为什么这样做好呢？**

设计原则中有一条叫单一职能原则，一个组件只负责明确的一件事，比如RigidBody只负责刚体，SpriteRender只负责渲染Sprite，而不是给一个硕大的组件把所有事情都干完

可能这样说比较抽象，我们来具体看看这样写的直接好处

+ 复用，因为组件的功能是独立的，所以任何需要检测自己是否站在地面上的东西都可以通过挂上PhysicCheck，并通过isGround来得到正确的结果
+ 所有有关地面检测的逻辑都在这里，假如有天你发现了更好的地面检测方法，可以一改全改，而不是辛辛苦苦去翻改每个地方的逻辑



不仅仅是地面检测，勇士传说很多地方都提现到了组件化的思想

负责记录血量分发受击事件的组件：`Calculate`

负责记录伤害管理hitbox的组件：`Attack`

这些组件都是抽象可复用的，当我们需要一个地刺就可以挂`Attack`，需要可破坏的场景物体就挂`Calculate`，需要可破坏的荆棘就`Attack`+`Calculate`



**总结**

如果希望调理清晰的项目代码，组件肯定是按各自的职责创建编写的

如果希望自己的代码能够在不同地方，甚至不同项目复用，就需要注意这种思想



## 	二、事件

### 首先什么是事件

+ 事件`UnityEvent<T>`是对C#委托`delegate`的安全封装

  而**委托是函数的容器**

  既然是容器，一类容器就只能装同类的东西（除非弱类型语言

+ `UnityEvent<T>`中 **T** 表示的是这个事件表示的是容器内函数的签名

  函数签名：函数的返回值、参数类型、参数个数

  事件和函数的签名是一一对应的

### 勇士传说的做法

![image-20231126151159023](https://image-wai.oss-cn-guangzhou.aliyuncs.com/img/image-20231126151159023.png)

因为玩家受击的时候，我希望玩家动画有反应，屏幕后处理有反应，玩家血量有反应

但不希望所有逻辑都写在一个地方，这就非常符合事件的使用场景

所以分发一个事件来通知所有对 *玩家死亡* 感兴趣的对象



## Scriptable Object

### 首先什么是SO

![image-20231126173231123](https://image-wai.oss-cn-guangzhou.aliyuncs.com/img/image-20231126173231123.png)

他是Unity给我们的一个继承自Object的类，他既不是GameObject也不是Component

意味着他不能挂在Hierarchy下面，也不能作为GameObject的组件

### SO的特性

+ 序列化
+ 过场景不销毁
+ 对象存放在Resource中

所以SO可以用来做数据配置，也可以作为一个单例，也可以作为事件分发的中间层



# 学习资料

+ C#：[唐老狮C#四部曲](https://space.bilibili.com/79983517/channel/seriesdetail?sid=602245)

  作为Unity游戏程序员，唐老狮C#四部曲讲的知识是早看晚看都得看的，**入门篇和基础篇**讲的都是一些基础C#语法、关键字、和简单数据结构，**核心篇**主要讲的是面向对象的特性和用法，**进阶篇**讲复杂一些的容器类和特殊语法。这些都是**游戏程序的基本功**，如果想要搞懂从麦扣教程里抄的代码都是什么意思，就需要耐下心来，边学边记笔记，在项目中成效哪怕不明显也要坚持，编程语言知识的积累是由量变到质变的。



+ Unity编程：[唐老狮Unity四部曲](https://space.bilibili.com/79983517/channel/seriesdetail?sid=602246)

  说是四部曲，其实大部分核心的东西都在入门篇讲完了，毕竟只是讲解Unity引擎的工作原理，API的使用，我们只需要熟悉最常用最基础的，了解学习方法以后，剩下的功能等做功能要用到时再查也不迟，**通过项目有一点了解以后，再看这个教程会有融会贯通、恍然大悟的感觉。**



+ Unity动画系统：[学习笔记 --- Unity动画系统](https://zhuanlan.zhihu.com/p/105029905)

  社团动作TA师兄写的文章，介绍了Unity动画系统大大小小每一个选项，每一个功能的作用，非常全面



# 合格的游戏程序

+ **数据方便配置**

  玩家控制器各种移动跳跃的数值，小怪巡逻点受击时间，诸如此类

  会影响游戏体验的数值，都应该集中起来方便修改配置

  策划在合并美术素材，确定最终游戏关卡的时候是一定是需要进引擎调数值测试的（如果不会，拷打他

  

+ **快速产出游戏原型**

  项目开始的时候，策划定好了游戏的核心玩法

  以最快速度做一个能验证核心体验的原型，让同步对游戏认知的途径从纸面的策划案到一个能动手玩的东西还是很重要的

  切忌一上来就闷头开发，写一大堆接口和继承，发现理解的需求不一样后重头全重来

  

+ **快速定位问题**

  开发的时候程序往往只是在自己的测试场景里，最终和其他部分合并到一起的时候会出各种各样的问题

  怎么样在问题出现的时候迅速意识到是什么原因，甚至预判哪里会出现问题

  

+ **敏锐的游戏审美**

  最终要做的是一个完整的游戏

  你需要根据玩过的游戏和策划的需求，判断自己做的来的效果是好的还是有待改进的

  如果有一个参考的游戏，第一步要做的就是打开这个游戏，一边玩一边思考，这个游戏的这个功能有什么细节，他可能是怎么实现的，我应该怎么样做才能实现这样的效果

  不知道该怎么做，离开引擎，打开游戏，再带着答案回到引擎。这个动作可能会在开发的时候反复出现很多次

  可能一个你已经沉浸了几十小时的游戏在你带着这样的眼光再回去看的时候，会获得全新的视角





